#! /usr/bin/ruby

#--
###############################################################################
#                                                                             #
# guess_encoding -- Assist with guessing the encoding of some input at hand   #
#   [A component of cmess, the encoding tool-box]                             #
#                                                                             #
# Copyright (C) 2007 University of Cologne,                                   #
#                    Albertus-Magnus-Platz,                                   #
#                    50932 Cologne, Germany                                   #
#                                                                             #
# Authors:                                                                    #
#     Jens Wille <jens.wille@uni-koeln.de>                                    #
#                                                                             #
# cmess is free software; you can redistribute it and/or modify it under the  #
# terms of the GNU General Public License as published by the Free Software   #
# Foundation; either version 3 of the License, or (at your option) any later  #
# version.                                                                    #
#                                                                             #
# cmess is distributed in the hope that it will be useful, but WITHOUT ANY    #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   #
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       #
# details.                                                                    #
#                                                                             #
# You should have received a copy of the GNU General Public License along     #
# with cmess. If not, see <http://www.gnu.org/licenses/>.                     #
#                                                                             #
###############################################################################
#++

# Outputs given string (or line), being encoded in target encoding, encoded in
# various test encodings, thus allowing to identify the (seemingly) correct
# encoding by visually comparing the input string with its desired appearance.

require 'optparse'
require 'iconv'

$: << File.join(File.dirname(__FILE__), '..', 'lib')

require 'cmess/version'

# our version ;-)
module GuessEncoding
  VERSION = '0.0.2'
end

PROGNAME = File.basename($0)

# default encodings to try
ENCODINGS = %w[
  ISO-8859-1
  ISO-8859-2
  ISO-8859-15
  CP1250
  CP1251
  CP1252
  CP850
  CP852
  CP856
  UTF-8
]

# likely candidates to suggest to the user
CANDIDATES = %w[
  ANSI_X3.4
  EBCDIC-AT-DE
  EBCDIC-US
  EUC-JP
  KOI-8
  MACINTOSH
  MS-ANSI
  SHIFT-JIS
  UTF-7
  UTF-16
  UTF-16BE
  UTF-16LE
  UTF-32
  UTF-32BE
  UTF-32LE
]

# how to split list of encodings
SPLIT_ENCODING_LIST_RE = /\s*[,\s]\s*/o

def determine_system_encoding
  ENV['SYSTEM_ENCODING']   ||
  ENV['LANG'][/\.(.*)/, 1] ||
  system_encoding_not_found
end

def system_encoding_not_found
  not_found = lambda {
    abort <<-EOT
Your system's encoding couldn't be determined automatically -- please specify it
explicitly via the SYSTEM_ENCODING environment variable or via the '-t' option.
    EOT
  }

  def not_found.to_s
    'NOT FOUND'
  end

  not_found
end

options = {
  :input                => STDIN,
  :line                 => 1,
  :encodings            => nil,
  :additional_encodings => [],
  :target_encoding      => determine_system_encoding
}

OptionParser.new(nil, 40) { |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.separator ''
  opts.separator 'Options:'

  opts.on('-i', '--input FILE', "Input file to read from [Default: STDIN]") { |f|
    abort "Can't find input file: #{f}" unless File.readable?(f)

    options[:input] = File.open(f)
  }

  opts.on('-l', '--line LINE', "Line number of input file to use for testing [Default: #{options[:line]}]") { |l|
    options[:line] = l.to_i

    unless options[:line] > 0
      options[:input].read  # prevent 'Broken pipe' error
      abort "Line number must be greater then 0!"
    end
  }

  opts.separator ''

  opts.on('-e', '--encodings ENCODINGS...', "List of encodings to try >instead of< default (see below)") { |e|
    options[:encodings] ||= []
    options[:encodings] += e.split(SPLIT_ENCODING_LIST_RE)
  }

  opts.on('-a', '--additional-encodings ENCODINGS...', "List of encodings to try >in addition to< default (see below)") { |e|
    options[:additional_encodings] += e.split(SPLIT_ENCODING_LIST_RE)
  }

  opts.separator ''

  opts.on('-t', '--target-encoding ENCODING', "Target encoding of your system [Default: #{options[:target_encoding]}]") { |e|
    options[:target_encoding] = e
  }

  opts.separator ''
  opts.separator 'Generic options:'

  opts.on('-h', '--help', "Print this help message and exit") {
    puts opts
    exit
  }

  opts.on('--version', "Print program version and exit") {
    puts "#{PROGNAME} v#{GuessEncoding::VERSION} (part of cmess v#{CMess::VERSION})"
    exit
  }

  opts.separator ''
  opts.separator 'Default encodings:'
  opts.separator ENCODINGS.join(', ')

  opts.separator ''
  opts.separator 'Likely candidates for additional testing:'
  opts.separator CANDIDATES.join(', ')
}.parse!

options[:target_encoding].call if options[:target_encoding].respond_to?(:call)

# reset line counter
$. = 0

input = options[:input].each { |line|
  break line if $. == options[:line]
}
abort "Input was empty!" if $..zero?
abort "Line not found -- input has only #{$.} line#{'s' if $. != 1}" unless input.is_a?(String)

target = options[:target_encoding]

encodings = (options[:encodings] || ENCODINGS) + options[:additional_encodings]
encodings = encodings.reverse.uniq.reverse     # uniq with additional encodings
                                               # staying at the end
encodings = [target] + (encodings - [target])  # move target encoding to front

max_length = encodings.map { |encoding| encoding.length }.max

encodings.each { |encoding|
  converted = begin
    Iconv.conv(target, encoding, input)
  rescue Iconv::IllegalSequence => err
    "ILLEGAL INPUT SEQUENCE: #{err}"
  rescue Iconv::InvalidEncoding
    if encoding == target
      abort "Invalid encoding: #{encoding}"
    else
      "INVALID ENCODING!"
    end
  end

  puts "%-#{max_length}s : %s" % [encoding, converted]
}
